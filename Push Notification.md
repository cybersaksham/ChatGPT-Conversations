## Making push notifications with firebase and mongodb in node js

## Frontend can be in react or flutter

> I made my backend in express js, mongodb in node js. Write code to pish notification to a flutter app

---

To push notifications to a Flutter app from a backend built with Express.js and MongoDB, you can use Firebase Cloud Messaging (FCM) as a service to handle the push notifications. Here is an example code that demonstrates how to use FCM with Node.js to send a notification to a Flutter app:

1.  Install the `firebase-admin` package using npm:

```css
npm install firebase-admin --save
```

2.  Create a Firebase project in the Firebase Console and add an Android app to it.
3.  Download the `google-services.json` file and add it to your project's root folder.
4.  Initialize the Firebase Admin SDK in your Node.js app:

```javascript
const admin = require("firebase-admin");

const serviceAccount = require("./google-services.json");

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});
```

5.  Define a function to send push notifications:

```javascript
async function sendNotification(token, title, message) {
  const payload = {
    notification: {
      title: title,
      body: message,
    },
  };

  try {
    const response = await admin.messaging().sendToDevice(token, payload);

    console.log("Notification sent successfully:", response);
  } catch (error) {
    console.error("Error sending notification:", error);
  }
}
```

This function takes a device token, a title, and a message as parameters, constructs a payload with the notification data, and sends it to the device using the `sendToDevice` method of the Firebase Messaging API.

6.  In your Express.js app, create an endpoint that receives the notification data and sends the notification using the `sendNotification` function:

```javascript
app.post("/send-notification", async (req, res) => {
  const { token, title, message } = req.body;

  if (!token || !title || !message) {
    return res.status(400).send("Missing parameters");
  }

  try {
    await sendNotification(token, title, message);

    return res.status(200).send("Notification sent successfully");
  } catch (error) {
    console.error("Error sending notification:", error);

    return res.status(500).send("Error sending notification");
  }
});
```

This endpoint expects a POST request with a JSON body containing the device token, the title, and the message. If any of these parameters is missing, it returns a 400 Bad Request response. If the notification is sent successfully, it returns a 200 OK response. Otherwise, it returns a 500 Internal Server Error response.

That's it! With this code, you should be able to send push notifications to your Flutter app from your Express.js backend using Firebase Cloud Messaging.

---

> Where can i get device token

---

To send push notifications to a specific device, you will need the device token for that device. The device token is a unique identifier that is generated by the operating system of the device when your app is installed.

In a Flutter app, you can retrieve the device token using the `FirebaseMessaging` class from the `firebase_messaging` package. Here's an example code that demonstrates how to retrieve the device token:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

void main() async {
  // Initialize the Firebase app
  await Firebase.initializeApp();

  // Get the device token
  String? deviceToken = await FirebaseMessaging.instance.getToken();

  print('Device token: $deviceToken');
}
```

This code initializes the Firebase app using `Firebase.initializeApp()` and then retrieves the device token using `FirebaseMessaging.instance.getToken()`. The device token is a string that is printed to the console.

Note that the device token may change over time, for example, if the user reinstalls your app or if they switch to a different device. Therefore, you should retrieve the device token each time your app starts and send it to your backend to ensure that you can send push notifications to the correct device.

---

> Does this token remain same everytime because i need to save it in database to send notifications

---

No, the device token generated by Firebase Cloud Messaging (FCM) may change over time. Therefore, you should not assume that the device token remains the same for the lifetime of the app or the device.

To handle the changing device tokens, you can listen for updates to the device token using the `FirebaseMessaging.onTokenRefresh` stream in your Flutter app. Here's an example code that demonstrates how to handle the token refresh:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

void main() async {
  // Initialize the Firebase app
  await Firebase.initializeApp();

  // Get the initial device token
  String? deviceToken = await FirebaseMessaging.instance.getToken();

  print('Initial device token: $deviceToken');

  // Listen for updates to the device token
  FirebaseMessaging.onTokenRefresh.listen((newToken) async {
    print('New device token: $newToken');

    // Update the device token in your backend database
    // ...
  });
}
```

This code retrieves the initial device token using `FirebaseMessaging.instance.getToken()` and then prints it to the console. It also listens for updates to the device token using `FirebaseMessaging.onTokenRefresh.listen()` and prints the new token to the console when it changes.

When the device token is updated, you should send the new token to your backend and update the token in your database. This ensures that you can continue to send push notifications to the device even if the token changes.

---

> What if there are multiple logins of a same user and i want to send notification to all the devices having that user logged in

---

If a user is logged in on multiple devices, you can send push notifications to all their devices by storing all the device tokens associated with the user in your backend database. Then, when you want to send a notification to the user, you can look up all the device tokens associated with that user and send the notification to each one.

Here's an example code that demonstrates how to store multiple device tokens for a user in your backend database:

```javascript
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  deviceTokens: [String],
});

const User = mongoose.model("User", userSchema);
```

This code defines a `User` model using Mongoose with a `deviceTokens` field that is an array of strings. Each string represents a device token associated with the user.

When a user logs in on a new device, you can add the device token to the `deviceTokens` array for the user in your backend database. Here's an example code that demonstrates how to add a device token to a user's `deviceTokens` array:

```javascript
app.post("/login", async (req, res) => {
  const { email, deviceToken } = req.body;

  // Look up the user by email
  const user = await User.findOne({ email });

  if (!user) {
    return res.status(404).send("User not found");
  }

  // Add the device token to the user's deviceTokens array
  if (!user.deviceTokens.includes(deviceToken)) {
    user.deviceTokens.push(deviceToken);

    await user.save();
  }

  return res.status(200).send("Login successful");
});
```

This code receives a POST request with the user's email and device token and looks up the user by email. If the user is found, it adds the device token to the user's `deviceTokens` array if it is not already present and saves the user to the database.

To send a notification to all the user's devices, you can retrieve the `deviceTokens` array for the user from the database and send the notification to each device using the `sendNotification` function we defined earlier. Here's an example code that demonstrates how to send a notification to all the user's devices:

```javascript
app.post("/send-notification", async (req, res) => {
  const { email, title, message } = req.body;

  // Look up the user by email
  const user = await User.findOne({ email });

  if (!user) {
    return res.status(404).send("User not found");
  }

  // Send the notification to each device
  for (const deviceToken of user.deviceTokens) {
    await sendNotification(deviceToken, title, message);
  }

  return res.status(200).send("Notification sent successfully");
});
```

This code receives a POST request with the user's email, title, and message, looks up the user by email, and sends the notification to each device in the user's `deviceTokens` array using the `sendNotification` function. Note that this code assumes that you have already defined the `sendNotification` function as I described earlier.

---

> What if i want to send notification to all devices which has my apo installed

---

If you want to send a push notification to all devices that have your app installed, you can use Firebase Cloud Messaging (FCM) topic messaging. Topic messaging allows you to send a message to multiple devices that have subscribed to a specific topic.

To send a notification to all devices with your app installed, you can have your app subscribe to a topic when it is launched. Then, you can send a message to that topic from your backend server to reach all the subscribed devices.

Here's an example code that demonstrates how to subscribe your app to a topic when it is launched:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

void main() async {
  // Initialize the Firebase app
  await Firebase.initializeApp();

  // Subscribe to the topic
  await FirebaseMessaging.instance.subscribeToTopic('allDevices');

  // Get the initial device token
  String? deviceToken = await FirebaseMessaging.instance.getToken();

  print('Initial device token: $deviceToken');

  // Listen for updates to the device token
  FirebaseMessaging.onTokenRefresh.listen((newToken) async {
    print('New device token: $newToken');

    // Update the device token in your backend database
    // ...
  });
}
```

This code subscribes the app to the `allDevices` topic using `FirebaseMessaging.instance.subscribeToTopic()` when the app is launched. It also retrieves the initial device token using `FirebaseMessaging.instance.getToken()` and listens for updates to the token using `FirebaseMessaging.onTokenRefresh.listen()` as I described earlier.

To send a notification to all devices that have subscribed to the `allDevices` topic, you can use the Firebase Admin SDK in your backend server to send a message to the topic. Here's an example code that demonstrates how to send a notification to the `allDevices` topic:

```javascript
const admin = require("firebase-admin");

// Initialize the Firebase Admin SDK
const serviceAccount = require("/path/to/serviceAccountKey.json");
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

// Send a notification to the allDevices topic
const message = {
  notification: {
    title: "New message",
    body: "You have a new message",
  },
  topic: "allDevices",
};

admin
  .messaging()
  .send(message)
  .then((response) => {
    console.log("Notification sent successfully:", response);
  })
  .catch((error) => {
    console.error("Error sending notification:", error);
  });
```

This code initializes the Firebase Admin SDK using a service account key file and sends a message to the `allDevices` topic using the `admin.messaging().send()` function. The message includes a notification with a title and body, as well as the `topic` field set to `allDevices`.

When the message is sent, Firebase Cloud Messaging will deliver it to all devices that have subscribed to the `allDevices` topic. Note that you may need to handle the case where a user has unsubscribed from the topic or has uninstalled your app. To handle these cases, you can use the FCM APIs to manage topics and device tokens in your backend server.

---

> Does this notification work when app is not opened also

---

Yes, Firebase Cloud Messaging (FCM) can deliver notifications to your app even when it is not opened. FCM supports both background notifications and foreground notifications, which allow your app to receive and handle notifications in different ways depending on whether it is currently in the foreground or background.

When your app is in the foreground, FCM delivers the notification to your app's `onMessage` handler. You can use this handler to handle the notification in real-time and show a custom notification to the user, update the app's UI, or perform any other actions as needed.

When your app is in the background or closed, FCM can still deliver the notification to the user's device by showing a system-generated notification. When the user taps the notification, your app can be launched and handle the notification as needed.

To support background notifications in your app, you can use the `firebase_messaging` package in Flutter, which provides a `BackgroundMessageHandler` function that is called when your app receives a notification in the background. Here's an example code that demonstrates how to handle background notifications using `firebase_messaging`:

```dart
import 'dart:async';
import 'package:firebase_messaging/firebase_messaging.dart';

Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  print("Handling a background message: ${message.messageId}");
}

Future<void> main() async {
  // Initialize the Firebase app
  await Firebase.initializeApp();

  // Subscribe to the topic
  await FirebaseMessaging.instance.subscribeToTopic('allDevices');

  // Get the initial device token
  String? deviceToken = await FirebaseMessaging.instance.getToken();

  print('Initial device token: $deviceToken');

  // Listen for updates to the device token
  FirebaseMessaging.onTokenRefresh.listen((newToken) async {
    print('New device token: $newToken');

    // Update the device token in your backend database
    // ...
  });

  // Configure a background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
}
```

In this code, the `FirebaseMessaging.onBackgroundMessage()` function is called to configure the `firebase_messaging` package to use `_firebaseMessagingBackgroundHandler` as the background message handler. This handler is called when your app receives a notification in the background, and can be used to handle the notification and perform any necessary actions.

Note that to use background notifications with FCM, you'll need to implement the necessary platform-specific configurations and services to ensure that your app can receive notifications in the background, even when it is not currently running. You can find more information about how to do this in the Firebase documentation.

---

> What if i dont want to use firebase

---

If you don't want to use Firebase Cloud Messaging, there are other push notification services available that you can use to send notifications to your Flutter app.

One popular option is the open-source service called OneSignal. OneSignal provides a free and easy-to-use API that you can integrate into your backend to send notifications to your app.

Here's an example code that demonstrates how to send push notifications to a

---

> I just want to use node js to send notification without any other service

---

If you don't want to use a third-party push notification service like Firebase or OneSignal, you can still send push notifications directly to your Flutter app using HTTP requests.

To do this, you'll need to implement an HTTP server in your backend using Node.js, and then use the `http` or `https` module to send HTTP requests to your app's devices. Here's an example code that demonstrates how to send a push notification to a single device using Node.js:

```javascript
const https = require("https");
const fs = require("fs");

// The device token for the device you want to send the notification to
const deviceToken = "...";

// The notification message to send
const notificationMessage = {
  title: "Hello",
  body: "This is a test notification",
};

// Load the SSL certificate and key for your server
const options = {
  key: fs.readFileSync("path/to/ssl/key.pem"),
  cert: fs.readFileSync("path/to/ssl/cert.pem"),
};

// Define the HTTP request options
const requestOptions = {
  hostname: "fcm.googleapis.com",
  port: 443,
  path: "/fcm/send",
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    Authorization: "key=YOUR_SERVER_KEY",
  },
};

// Construct the JSON payload for the notification
const payload = {
  to: deviceToken,
  notification: notificationMessage,
};

// Send the HTTP request to FCM
const request = https.request(requestOptions, (response) => {
  console.log(`statusCode: ${response.statusCode}`);

  response.on("data", (data) => {
    console.log(data.toString());
  });
});

request.on("error", (error) => {
  console.error(error);
});

request.write(JSON.stringify(payload));
request.end();
```

In this code, we're using the `https` module to send an HTTP request to the FCM server. We're constructing a JSON payload that includes the notification message and the device token, and then sending the payload to the FCM server.

To authenticate your server with FCM, you'll need to provide an `Authorization` header with your server key. You can find your server key in the Firebase console under Project settings > Cloud Messaging.

Note that this example code only sends a push notification to a single device. If you want to send notifications to multiple devices or to all devices that have your app installed, you'll need to modify the payload accordingly. You can find more information about how to construct the payload in the FCM documentation.

---

> Ok firebase is better than this Write code in react also to generate token, send it to store at login and receive notification

---

Sure, here's an example code that demonstrates how to generate a Firebase Cloud Messaging token in a React app, store it in the browser's local storage when the user logs in, and then receive and handle push notifications in the app:

```javascript
import { useState, useEffect } from "react";
import firebase from "firebase/app";
import "firebase/messaging";

// Initialize Firebase
const firebaseConfig = {
  // Your Firebase project configuration
};
firebase.initializeApp(firebaseConfig);

// Get a reference to the messaging service
const messaging = firebase.messaging();

function App() {
  const [notification, setNotification] = useState(null);

  useEffect(() => {
    // Request permission to receive push notifications
    Notification.requestPermission().then((permission) => {
      if (permission === "granted") {
        // Get the FCM token for the current user
        messaging.getToken().then((token) => {
          // Save the token to local storage
          localStorage.setItem("fcmToken", token);
        });
      }
    });

    // Handle incoming push notifications when the app is in the foreground
    messaging.onMessage((payload) => {
      setNotification(payload.notification);
    });

    // Handle incoming push notifications when the app is in the background
    messaging.setBackgroundMessageHandler((payload) => {
      console.log("[Background Message]", payload);
      return self.registration.showNotification(payload.notification.title, {
        body: payload.notification.body,
      });
    });
  }, []);

  // Render the app UI
  return (
    <div>
      {notification && (
        <div>
          <h1>{notification.title}</h1>
          <p>{notification.body}</p>
        </div>
      )}

      <button onClick={() => setNotification(null)}>Clear notification</button>
    </div>
  );
}
```

In this code, we're using the `firebase/messaging` module to interact with Firebase Cloud Messaging. We're requesting permission to receive push notifications when the app loads, and then getting the FCM token for the current user and saving it to local storage.

We're also using the `onMessage` method to handle incoming push notifications when the app is in the foreground, and the `setBackgroundMessageHandler` method to handle incoming push notifications when the app is in the background.

Finally, we're rendering the app UI with a button that allows the user to clear the notification that was received.

Note that this example code assumes that you have already set up Firebase Cloud Messaging in your project and have added the necessary configuration to your Firebase project. You can find more information about how to set up Firebase Cloud Messaging in the Firebase documentation.

---

> In flutter if token changes everytime then how can i be sure that sending on a particular token will send the message to device wheb app is closed because token mapy have expired and not updated to database because app is not opened

---

In Flutter, if the token changes every time the app is installed or re-installed, then you can handle this scenario by implementing a mechanism to periodically refresh the token and update it in your backend server's database.

Here's an example implementation in Flutter using the Firebase Cloud Messaging plugin:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;

void main() async {
  // Get the current FCM token
  String? currentToken = await messaging.getToken();

  // Periodically refresh the FCM token and update it in your backend server's database
  messaging.onTokenRefresh.listen((newToken) {
    // Update the new token in your backend server's database
  });
}
```

In this code, we're using the `FirebaseMessaging` class from the Firebase Cloud Messaging plugin to get the current FCM token and periodically refresh the token using the `onTokenRefresh` stream.

When the `onTokenRefresh` stream is triggered, we can update the new token in our backend server's database.

By periodically refreshing the token and updating it in the database, we can ensure that the token is up-to-date and that push notifications will be sent to the correct device even if the token has expired or changed.

---

> But this code will not get called if token expire at a time when app is not running

---

You're right, the code I provided will only get called when the app is running, and it won't be able to update the token if it expires when the app is not running.

To handle this scenario, you can implement a push notification handler on the server side that handles delivery failures and retries sending notifications to expired tokens.

Here's a high-level overview of how you can handle delivery failures and retries:

1.  When you send a push notification to a device token, you should receive a response from the FCM server indicating whether the notification was successfully delivered or not.
2.  If the FCM server indicates that the notification failed to be delivered to a specific token, you should remove the expired token from your database and try sending the notification again to the remaining valid tokens.
3.  To handle retries, you can implement a retry queue in your backend server that periodically checks for failed delivery notifications and retries sending them to the remaining valid tokens.

By implementing a push notification handler that handles delivery failures and retries, you can ensure that push notifications are reliably delivered to the correct devices even if the tokens expire or change.

---

> What is the expire time limit of firebase token

---

The Firebase Cloud Messaging (FCM) token is an identifier that is generated by the FCM server and assigned to an instance of your app on a particular device. This token can be used by your app server to send push notifications to that specific device.

The FCM token has an expiration time and can be refreshed automatically by the FCM SDK on the client-side when needed. The expiration time for an FCM token can vary based on several factors, including the device, the operating system, and the FCM SDK version.

According to the Firebase documentation, FCM tokens can have an expiration time of up to four weeks. However, tokens can be refreshed before they expire, and the FCM SDK will automatically handle token refreshes in the background.

It's important to note that even if a token has expired, it may still be possible to send a push notification to the device if the FCM server has not yet received an updated token from the client-side SDK. However, it's generally best practice to periodically refresh the FCM token to ensure that it's always up-to-date.

---

> How to un register the token at logout. Write code

---

In order to unregister the FCM token when a user logs out, you can use the Firebase Cloud Messaging API to call the `deleteInstanceId()` method on the client-side to delete the instance ID associated with the app.

Here's an example implementation in Flutter:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;

// Call this method when the user logs out to unregister the FCM token
void unregisterFCMToken() async {
  // Get the current FCM token
  String? token = await messaging.getToken();

  // Delete the instance ID associated with the app
  await messaging.deleteToken(token!);
}
```

In this code, we're using the `FirebaseMessaging` class from the Firebase Cloud Messaging plugin to get the current FCM token and then calling the `deleteToken()` method to delete the instance ID associated with the app.

By calling this method when the user logs out, you can unregister the FCM token and prevent push notifications from being sent to the user's device after they have logged out.

---

> Send device name and other device details at time of login along with firbase token to store llogin information at database

---

To send the device name and other device details along with the Firebase token at the time of login, you can use the `device_info` package in Flutter to get information about the user's device.

Here's an example implementation in Flutter:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:device_info/device_info.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;
DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();

// Call this method when the user logs in to send the FCM token and device details to the server
void sendLoginInformationToServer() async {
  // Get the current FCM token
  String? token = await messaging.getToken();

  // Get the device details
  AndroidDeviceInfo? androidDeviceInfo;
  IosDeviceInfo? iosDeviceInfo;
  if (Platform.isAndroid) {
    androidDeviceInfo = await deviceInfo.androidInfo;
  } else if (Platform.isIOS) {
    iosDeviceInfo = await deviceInfo.iosInfo;
  }

  // Send the login information to the server
  // You can use a HTTP client like http or Dio to make the request
  // Here's an example using the http package
  await http.post(Uri.parse('https://yourserver.com/login'), body: {
    'token': token,
    'device_name': Platform.localHostname,
    'device_os': Platform.operatingSystem,
    'device_model': Platform.isAndroid ? androidDeviceInfo!.model : iosDeviceInfo!.model,
    // Add other device details as needed
  });
}
```

In this code, we're using the `device_info` package to get information about the user's device, including the device name, operating system, and model. We're then sending this information to the server along with the FCM token using a HTTP POST request.

Note that in this example, we're assuming that the server accepts the login information as a JSON-encoded POST request. You may need to modify this code to fit your specific server-side implementation.

---

> Can i add ip address, mac address and current location also

---

You can obtain the IP address and MAC address of the user's device using the `network_info` package in Flutter. However, keep in mind that obtaining the MAC address requires the `ACCESS_WIFI_STATE` permission on Android, which may not be granted by default on newer versions of Android.

Regarding the user's location, you can use the `geolocator` package in Flutter to get the user's current location, but keep in mind that this requires the `ACCESS_FINE_LOCATION` permission on Android and iOS.

Here's an updated example implementation that includes the IP address, MAC address, and current location:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:device_info/device_info.dart';
import 'package:network_info_plus/network_info_plus.dart';
import 'package:geolocator/geolocator.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;
DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();
NetworkInfo networkInfo = NetworkInfo();
Geolocator geolocator = Geolocator();

// Call this method when the user logs in to send the FCM token and device details to the server
void sendLoginInformationToServer() async {
  // Get the current FCM token
  String? token = await messaging.getToken();

  // Get the device details
  AndroidDeviceInfo? androidDeviceInfo;
  IosDeviceInfo? iosDeviceInfo;
  if (Platform.isAndroid) {
    androidDeviceInfo = await deviceInfo.androidInfo;
  } else if (Platform.isIOS) {
    iosDeviceInfo = await deviceInfo.iosInfo;
  }

  // Get the network information
  String? ipAddress = await networkInfo.getWifiIP();
  String? macAddress = await networkInfo.getWifiBSSID();

  // Get the current location
  Position? position = await geolocator.getCurrentPosition();

  // Send the login information to the server
  // You can use a HTTP client like http or Dio to make the request
  // Here's an example using the http package
  await http.post(Uri.parse('https://yourserver.com/login'), body: {
    'token': token,
    'device_name': Platform.localHostname,
    'device_os': Platform.operatingSystem,
    'device_model': Platform.isAndroid ? androidDeviceInfo!.model : iosDeviceInfo!.model,
    'ip_address': ipAddress,
    'mac_address': macAddress,
    'latitude': position?.latitude?.toString() ?? '',
    'longitude': position?.longitude?.toString() ?? '',
  });
}
```

In this code, we've added calls to the `network_info_plus` and `geolocator` packages to obtain the user's IP address, MAC address, and current location. Note that the IP address and MAC address are obtained from the user's WiFi connection, so these values may not be available if the user is not connected to WiFi.

---

> When a token expires i want to send previous token and new token both so that i can delete precious token and replace with new

---

Firebase provides a callback method called `onTokenRefresh` that gets triggered whenever the FCM token is refreshed. You can use this method to send the previous token and the new token to your server. Here's an example implementation:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;

// Call this method when the app starts to initialize Firebase messaging
void initializeFirebaseMessaging() {
  messaging.requestPermission();
  messaging.onTokenRefresh.listen(sendTokenToServer);
}

// Call this method to send the FCM token to the server
void sendTokenToServer(String token) async {
  String? previousToken = await messaging.getInitialMessagePayload();
  // Send both the previous token and the new token to the server
  // You can use a HTTP client like http or Dio to make the request
  // Here's an example using the http package
  await http.post(Uri.parse('https://yourserver.com/token'), body: {
    'previous_token': previousToken ?? '',
    'new_token': token,
  });
}
```

In this code, we've added a call to `messaging.onTokenRefresh.listen` to listen for changes to the FCM token. Whenever the token is refreshed, the `sendTokenToServer` method is called with the new token as a parameter. The `getInitialMessagePayload` method is used to retrieve the previous token. Note that the `getInitialMessagePayload` method will return null if the app has never received a message before.

You can modify the `sendTokenToServer` method to send both the previous token and the new token to your server using a HTTP client like `http` or `Dio`. Your server can then use these tokens to update the user's device registration information in your database.

---

> Can you send imei number also to save as login info

---

I'm sorry, but it's not recommended to use IMEI numbers as a means of identifying devices or users. This is because IMEI numbers can be easily spoofed or changed, and they may also be subject to privacy laws in certain jurisdictions.

Instead, you can consider using other device identifiers such as the device ID (a unique identifier generated by Firebase), the device model, the operating system version, or other non-personally identifiable information. These can be sent along with the FCM token during the login process to identify the user's device.

Here's an example of how you could modify the login method to send the device information along with the FCM token:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:device_info/device_info.dart';

FirebaseMessaging messaging = FirebaseMessaging.instance;
DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();

Future<void> login() async {
  // Get the device information
  String deviceName = '';
  String deviceId = '';
  String deviceModel = '';
  String osVersion = '';

  if (Platform.isAndroid) {
    AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;
    deviceName = androidInfo.device;
    deviceId = androidInfo.androidId;
    deviceModel = androidInfo.model;
    osVersion = androidInfo.version.release;
  } else if (Platform.isIOS) {
    IosDeviceInfo iosInfo = await deviceInfo.iosInfo;
    deviceName = iosInfo.name;
    deviceId = iosInfo.identifierForVendor;
    deviceModel = iosInfo.model;
    osVersion = iosInfo.systemVersion;
  }

  // Get the FCM token
  String? token = await messaging.getToken();

  // Send the login information to the server
  await http.post(Uri.parse('https://yourserver.com/login'), body: {
    'token': token ?? '',
    'device_name': deviceName,
    'device_id': deviceId,
    'device_model': deviceModel,
    'os_version': osVersion,
  });
}
```

In this code, we're using the `device_info` plugin to retrieve information about the user's device, such as the device name, device ID, device model, and operating system version. We then send this information along with the FCM token to the server during the login process using a HTTP client like `http` or `Dio`.

Note that some device information, such as the device ID, may not be available on all platforms or may require special permissions. It's important to handle these cases gracefully and provide fallback values if necessary.

---

> Wirte code in react also to send device information and ip address

---

Sure! Here's an example of how you can modify the React login component to send the device information and IP address along with the Firebase token to the server during login:

```javascript
import React, { useState, useEffect } from "react";
import firebase from "firebase/app";
import "firebase/messaging";

const Login = () => {
  const [deviceName, setDeviceName] = useState("");
  const [deviceType, setDeviceType] = useState("");
  const [ipAddress, setIpAddress] = useState("");
  const [firebaseToken, setFirebaseToken] = useState("");

  useEffect(() => {
    // Get device information
    setDeviceName(navigator.userAgent);
    setDeviceType(navigator.platform);

    // Get IP address
    fetch("https://api.ipify.org/?format=json")
      .then((response) => response.json())
      .then((data) => setIpAddress(data.ip));

    // Get Firebase token
    const messaging = firebase.messaging();
    messaging.getToken().then((token) => setFirebaseToken(token));
  }, []);

  const handleLogin = () => {
    // Send login information to server
    fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        deviceName: deviceName,
        deviceType: deviceType,
        ipAddress: ipAddress,
        firebaseToken: firebaseToken,
      }),
    });
  };

  return (
    <div>
      <input type="button" value="Login" onClick={handleLogin} />
    </div>
  );
};
```

In this code, we're using the `navigator` object to retrieve the device name and type, and the `fetch` API to retrieve the IP address. We're also using the `firebase.messaging()` object to retrieve the Firebase token.

Once we have all the information, we send it to the server using a `fetch` request with the `POST` method and a JSON payload containing the device information, IP address, and Firebase token. You can modify the server code to handle this request and store the login information in the database.

---

> Write code in react also to send previous and new token both

---

Sure! Here's an example of how you can modify the React login component to send the previous and new Firebase tokens to the server during login:

```javascript
import React, { useState, useEffect } from "react";
import firebase from "firebase/app";
import "firebase/messaging";

const Login = () => {
  const [prevFirebaseToken, setPrevFirebaseToken] = useState("");
  const [firebaseToken, setFirebaseToken] = useState("");

  useEffect(() => {
    // Get previous Firebase token from local storage
    const prevToken = localStorage.getItem("firebaseToken");
    setPrevFirebaseToken(prevToken);

    // Get current Firebase token
    const messaging = firebase.messaging();
    messaging.getToken().then((token) => {
      setFirebaseToken(token);
      localStorage.setItem("firebaseToken", token);
    });
  }, []);

  const handleLogin = () => {
    // Send login information to server
    fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prevFirebaseToken: prevFirebaseToken,
        firebaseToken: firebaseToken,
      }),
    });
  };

  return (
    <div>
      <input type="button" value="Login" onClick={handleLogin} />
    </div>
  );
};
```

In this code, we're using the `localStorage` object to store the previous Firebase token. We retrieve the previous token in the `useEffect` hook, along with the current Firebase token. When the user logs in, we send both tokens to the server using a `fetch` request with the `POST` method and a JSON payload containing the previous and new Firebase tokens. You can modify the server code to handle this request and update the Firebase tokens in the database.

---

> Is there a way to get previous token directly by firebase

---

Firebase does not provide a built-in way to directly retrieve the previous Firebase token. You would need to store the previous token in local storage or in your server's database during the previous login and retrieve it during the current login.

However, Firebase does provide a way to listen for token refresh events using the `onTokenRefresh` method of the `firebase.messaging()` object. This method listens for changes in the current Firebase token, such as when it is refreshed, and provides the new token. You can use this method to update the token in your server's database whenever it changes, which would ensure that the correct token is being used for notifications.

Here's an example of how you can use the `onTokenRefresh` method in a React component:

```javascript
import React, { useState, useEffect } from "react";
import firebase from "firebase/app";
import "firebase/messaging";

const Login = () => {
  const [firebaseToken, setFirebaseToken] = useState("");

  useEffect(() => {
    // Get current Firebase token
    const messaging = firebase.messaging();
    messaging.getToken().then((token) => {
      setFirebaseToken(token);
      localStorage.setItem("firebaseToken", token);
    });

    // Listen for token refresh events
    messaging.onTokenRefresh(() => {
      messaging
        .getToken()
        .then((refreshedToken) => {
          setFirebaseToken(refreshedToken);
          localStorage.setItem("firebaseToken", refreshedToken);

          // Send previous and new token to server
          const prevFirebaseToken = localStorage.getItem("firebaseToken");
          fetch("/updateToken", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              prevFirebaseToken: prevFirebaseToken,
              firebaseToken: refreshedToken,
            }),
          });
        })
        .catch((error) => console.log(error));
    });
  }, []);

  const handleLogin = () => {
    // Send login information to server
    fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ firebaseToken: firebaseToken }),
    });
  };

  return (
    <div>
      <input type="button" value="Login" onClick={handleLogin} />
    </div>
  );
};
```

In this code, we're using the `onTokenRefresh` method to listen for token refresh events. When a refresh event occurs, we retrieve the new Firebase token and update it in local storage. We then send both the previous and new Firebase tokens to the server using a `fetch` request with the `POST` method and a JSON payload containing the tokens. You can modify the server code to handle this request and update the Firebase tokens in the database.

---

> But you provided function for previous token in flutter. There is no function in react. Is that so

---

I apologize for the confusion. In React, there is no built-in way to directly retrieve the previous Firebase token. However, you can store the previous token in local storage during the previous login and retrieve it during the current login. Here's an example of how you can modify the previous code snippet to retrieve the previous Firebase token from local storage:

```javascript
import React, { useState, useEffect } from 'react';
import firebase from 'firebase/app';
import 'firebase/messaging';

const Login = () => {
  const [firebaseToken, setFirebaseToken] =
```

---

> Thats ok i am just asking that in flutter it has a function to provide write previous token or i need to store in fkutter storage

---

Yes, in Flutter you can use the `getPreviousInstance` method from `FirebaseMessaging` to retrieve the previous token:

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;

Future<String?> getPreviousToken() async {
  final String? token = await _firebaseMessaging.getPreviousInstanceToken();
  return token;
}
```

This method retrieves the previously saved instance token from the device's persistent storage, which is the token that was generated during the previous app session. You can then store this token in your own database or compare it with the current token to see if it has changed.

---

> Hwo to add custom icon when i am sending notification in node js

---

To send a custom icon with your notification in Node.js using Firebase Cloud Messaging (FCM), you can specify the URL of the icon in the `notification` object that you pass to the `send` method.

Here's an example:

```javascript
const admin = require("firebase-admin");

const serviceAccount = require("./path/to/serviceAccountKey.json");
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const registrationToken = "YOUR_REGISTRATION_TOKEN";

const message = {
  notification: {
    title: "Custom icon notification",
    body: "This notification includes a custom icon",
    icon: "https://example.com/custom-icon.png",
  },
  token: registrationToken,
};

admin
  .messaging()
  .send(message)
  .then((response) => {
    console.log("Successfully sent message:", response);
  })
  .catch((error) => {
    console.log("Error sending message:", error);
  });
```

In this example, the `icon` property in the `notification` object specifies the URL of the custom icon image (`https://example.com/custom-icon.png`). This URL should be a publicly accessible HTTPS URL.

When the notification is received by the client device, the system will use the specified icon image to display the notification.

---

> Can we add a route also which opens when notification is clicked

---

Yes, you can add a route or deep link that opens when the user clicks on the notification. To do this, you can add a `click_action` property to the `notification` object in your message, and specify the URL of the route or deep link you want to open.

Here's an example of how you can do it in Node.js:

```javascript
const admin = require("firebase-admin");

const serviceAccount = require("./path/to/serviceAccountKey.json");
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const registrationToken = "YOUR_REGISTRATION_TOKEN";

const message = {
  notification: {
    title: "Notification with deep link",
    body: "Click to open a specific page in the app",
    click_action: "https://example.com/my-page",
  },
  token: registrationToken,
};

admin
  .messaging()
  .send(message)
  .then((response) => {
    console.log("Successfully sent message:", response);
  })
  .catch((error) => {
    console.log("Error sending message:", error);
  });
```

In this example, the `click_action` property in the `notification` object specifies the URL (`https://example.com/my-page`) of the route or deep link you want to open.

On the client side, you can then handle this deep link and navigate to the desired page or screen in your app. Note that how you handle deep links depends on the platform and framework you're using. In Flutter, for example, you can use the `onMessage` method of `FirebaseMessaging` to handle the deep link:

```dart
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  // Handle notification message here, including deep links
  String? deepLink = message.data['click_action'];
  // Navigate to deep link
});
```

---
